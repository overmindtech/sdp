syntax = "proto3";

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

package account;

option go_package = "github.com/overmindtech/sdp-go;sdp";

//                            _
//       .::::::::::.        -(_)====u         .::::::::::.
//     .::::''''''::::.                      .::::''''''::::.
//   .:::'          `::::....          ....::::'          `:::.
//  .::'             `:::::::|        |:::::::'             `::.
// .::|               |::::::|_ ___ __|::::::|               |::.
// `--'               |::::::|_()__()_|::::::|               `--'
//  :::               |::-o::|        |::o-::|               :::
//  `::.             .|::::::|        |::::::|.             .::'
//   `:::.          .::\-----'        `-----/::.          .:::'
//     `::::......::::'                      `::::......::::'
//       `::::::::::'                          `::::::::::'
// Credit: https://www.asciiart.eu/

// The admin service allows users with Admin privileges to any account. Many of
// the RPCs in this service mirror RPCs in the ManagementService, but allow the
// user to specfy an account to operate on, rather than using the account that
// the user belongs to.
service AdminService {
    // Lists the details of all NATS Accounts
    rpc ListAccounts(ListAccountsRequest) returns (ListAccountsResponse);
    // Creates a new account, public_nkey will be autogenerated
    rpc CreateAccount(CreateAccountRequest) returns (CreateAccountResponse);
    // Get the details of a given account
    rpc GetAccount(AdminGetAccountRequest) returns (GetAccountResponse);
    // Deletes an account from Overmind. If a user logs in again, they will get
    // a completely new account provisioned for them
    rpc DeleteAccount(AdminDeleteAccountRequest) returns (AdminDeleteAccountResponse);
    // Deletes a user from Auth0, this does not delete the Overmind account that
    // they are attached to ad should be used in conjunction with DeleteAccount
    // if the user is intending to delete everything Overmind has on them
    rpc DeleteUser(AdminDeleteUserRequest) returns (AdminDeleteUserResponse);

    // Lists all sources within the closen account
    rpc ListSources(AdminListSourcesRequest) returns (ListSourcesResponse);
    // Creates a new source within the closen account
    rpc CreateSource(AdminCreateSourceRequest) returns (CreateSourceResponse);
    // Get the details of a source within the closen account
    rpc GetSource(AdminGetSourceRequest) returns (GetSourceResponse);
    // Update the details of a source within the closen account
    rpc UpdateSource(AdminUpdateSourceRequest) returns (UpdateSourceResponse);
    // Deletes a source from a closen account
    rpc DeleteSource(AdminDeleteSourceRequest) returns (DeleteSourceResponse);

    // Updates sources to keep them running in the background. This can be used
    // to add explicit action, when the built-in keepalives are not sufficient.
    rpc KeepaliveSources(AdminKeepaliveSourcesRequest) returns (KeepaliveSourcesResponse);

    // Create a new NATS token for a given public NKey. The user requesting must
    // control the associated private key also in order to connect to NATS as
    // the token is not enough on its own
    rpc CreateToken(AdminCreateTokenRequest) returns (CreateTokenResponse);

}

// TOOD: Decide if I should have the admin requests return the exact same
// responses as the non-admin ones or should I change it?

message ListAccountsRequest {}
message ListAccountsResponse {
    repeated Account accounts = 1;
}

message CreateAccountRequest {
    AccountProperties properties = 1;
}
message CreateAccountResponse {
    Account account = 1;
}

message AdminGetAccountRequest {
    // The name of the account to get
    string name = 1;
}

message AdminDeleteAccountRequest {
    // The name of the account to delete
    string name = 1;
}
message AdminDeleteAccountResponse {}

message AdminDeleteUserRequest {
    // The email of the user to delete
    string email = 1;
}
message AdminDeleteUserResponse {}

message AdminListSourcesRequest {
    string account = 1;
    ListSourcesRequest request = 2;
}
message AdminCreateSourceRequest {
    string account = 1;
    CreateSourceRequest request = 2;
}
message AdminGetSourceRequest {
    string account = 1;
    GetSourceRequest request = 2;
}
message AdminUpdateSourceRequest {
    string account = 1;
    UpdateSourceRequest request = 2;
}
message AdminDeleteSourceRequest {
    string account = 1;
    DeleteSourceRequest request = 2;
}
message AdminKeepaliveSourcesRequest {
    string account = 1;
    KeepaliveSourcesRequest request = 2;
}
message AdminCreateTokenRequest {
    string account = 1;
    CreateTokenRequest request = 2;
}

// RPCs to manage the user's account, sources etc. All requests to this API are
// scoped to that user's account via the
// `https://api.overmind.tech/account-name` claim in the suppplied token
service ManagementService {
    // Get the details of the account that this user belongs to
    rpc GetAccount(GetAccountRequest) returns (GetAccountResponse);
    
    // Deletes the user's account. If a user calls this and logs in again, they
    // will get a completely new account provisioned for them
    rpc DeleteAccount(DeleteAccountRequest) returns (DeleteAccountResponse);

    // Deletes the user's account. This will remove the user from Auth0 entirely
    // and they will need to sign up again. If a user is intending to delete
    // everything Overmind has on them, they should use DeleteAccount to delete
    // their Overmind account and all the data it contains, then call this to
    // remove themselves from Auth0
    rpc DeleteOwnUser(DeleteOwnUserRequest) returns (DeleteOwnUserResponse);

    // Lists all sources within the user's account
    rpc ListSources(ListSourcesRequest) returns (ListSourcesResponse);
    // Creates a new source within the user's account
    rpc CreateSource(CreateSourceRequest) returns (CreateSourceResponse);
    // Get the details of a source
    rpc GetSource(GetSourceRequest) returns (GetSourceResponse);
    // Update the details of a source
    rpc UpdateSource(UpdateSourceRequest) returns (UpdateSourceResponse);
    // Deletes a source from a user's account
    rpc DeleteSource(DeleteSourceRequest) returns (DeleteSourceResponse);

    // Updates sources to keep them running in the background. This can be used
    // to add explicit action, when the built-in keepalives are not sufficient.
    rpc KeepaliveSources(KeepaliveSourcesRequest) returns (KeepaliveSourcesResponse);

    // Create a new NATS token for a given public NKey. The user requesting must
    // control the associated private key also in order to connect to NATS as
    // the token is not enough on its own
    rpc CreateToken(CreateTokenRequest) returns (CreateTokenResponse);
}

enum SourceStatus {
    STATUS_UNSPECIFIED = 0;
    // The source is starting or updating
    STATUS_PROGRESSING = 1;
    // The source is healthy
    STATUS_HEALTHY = 2;
    // The source is unhealthy
    STATUS_UNHEALTHY = 3;
}

message Source {
    SourceMetadata metadata = 1;
    SourceProperties properties = 2;
}

message SourceMetadata {
    bytes UUID = 1; // TOOD: Change to ID along with everything else

    // The name of the NATS JWT that has been generated for this source
    string TokenName = 2;

    // When the NATS JWT expires (unix time)
    google.protobuf.Timestamp TokenExpiry = 4;

    // The public NKey associated with the NATS JWT
    string PublicNkey = 5;

    // Status of the source
    SourceStatus Status = 9;

    // The error message if the source is unhealthy
    string Error = 10;

}

// A source that is capable of discovering items
message SourceProperties {
    // The descriptive name of the source
    string DescriptiveName = 1;

    // What source to configure. Currently either "stdlib" or "aws"
    string Type = 2;

    // Config for this source. See the source documentation for what
    // source-specific config is available/required. This will be supplied
    // directly to viper via a config file at `/etc/srcman/config/source.yaml`
    google.protobuf.Struct Config = 3;

    // Additional config options that should be passed to the source. The keys
    // of this object should be file names, and the values should be their
    // content. These files will be made available to the source at runtime.
    // Check the source's documentation for what to configure here if required
    google.protobuf.Struct AdditionalConfig = 4;
}

message Account {
    AccountMetadata metadata = 1;
    AccountProperties properties = 2;
}

message AccountMetadata {
    // The public Nkey which signs all NATS "user" tokens
    string PublicNkey = 2;
}

message AccountProperties {
    // The name of the account
    string Name = 1;
}

message GetAccountRequest {}
message GetAccountResponse {
   Account account = 1;
}

message DeleteAccountRequest {
    // Set to true to confirm that the user is sure they want to delete their
    // account. This is to prevent accidental deletions
    bool iAmSure = 1;
}
message DeleteAccountResponse {}

message DeleteOwnUserRequest {
    // Set to true to confirm that the user is sure they want to delete their
    // user. This is to prevent accidental deletions
    bool iAmSure = 1;
}
message DeleteOwnUserResponse {}

message ListSourcesRequest {}
message ListSourcesResponse {
    repeated Source Sources = 1;
}

message CreateSourceRequest {
    SourceProperties properties = 1;
}

message CreateSourceResponse {
    Source source = 1;
}

message GetSourceRequest {
    bytes UUID = 1;
}

message GetSourceResponse {
    Source source = 1;
}

message UpdateSourceRequest {
    // ID of the source to update
    bytes UUID = 1;
    // Properties to update
    SourceProperties properties = 2;
}

message UpdateSourceResponse {
    Source source = 1;
}

message DeleteSourceRequest {
    // ID if the source to delete
    bytes UUID = 1;
}

message DeleteSourceResponse {}

message KeepaliveSourcesRequest {
    // Set to true to have the API call wait until the source is up and healthy
    bool waitForHealthy = 1;
}
message KeepaliveSourcesResponse {
}

message CreateTokenRequest {
    // The Public NKey of the user that is requesting a token
    string userPublicNkey = 1;

    // Friendly user name
    string userName = 2;
}

message CreateTokenResponse {
    // The JWT as a raw string
    string token = 1;
}
