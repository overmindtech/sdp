syntax = "proto3";

import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

package account;

option go_package = "github.com/overmindtech/sdp-go;sdp";

//                            _
//       .::::::::::.        -(_)====u         .::::::::::.
//     .::::''''''::::.                      .::::''''''::::.
//   .:::'          `::::....          ....::::'          `:::.
//  .::'             `:::::::|        |:::::::'             `::.
// .::|               |::::::|_ ___ __|::::::|               |::.
// `--'               |::::::|_()__()_|::::::|               `--'
//  :::               |::-o::|        |::o-::|               :::
//  `::.             .|::::::|        |::::::|.             .::'
//   `:::.          .::\-----'        `-----/::.          .:::'
//     `::::......::::'                      `::::......::::'
//       `::::::::::'                          `::::::::::'
// Credit: https://www.asciiart.eu/

// The admin service allows users with Admin privileges to any account. Many of
// the RPCs in this service mirror RPCs in the ManagementService, but allow the
// user to specify an account to operate on, rather than using the account that
// the user belongs to.
service AdminService {
    // Lists the details of all NATS Accounts
    rpc ListAccounts(ListAccountsRequest) returns (ListAccountsResponse);
    // Creates a new account, public_nkey will be autogenerated
    rpc CreateAccount(CreateAccountRequest) returns (CreateAccountResponse);
    // Updates account details, returns the account
    rpc UpdateAccount(AdminUpdateAccountRequest) returns (UpdateAccountResponse);
    // Get the details of a given account
    rpc GetAccount(AdminGetAccountRequest) returns (GetAccountResponse);
    // Completely deletes an account. This includes all of the data in that
    // account, bookmarks, changes etc. It also deletes all users from Auth0
    // that are associated with this account
    rpc DeleteAccount(AdminDeleteAccountRequest) returns (AdminDeleteAccountResponse);

    // Lists all sources within the chosen account
    rpc ListSources(AdminListSourcesRequest) returns (ListSourcesResponse);
    // Creates a new source within the chosen account
    rpc CreateSource(AdminCreateSourceRequest) returns (CreateSourceResponse);
    // Get the details of a source within the chosen account
    rpc GetSource(AdminGetSourceRequest) returns (GetSourceResponse);
    // Update the details of a source within the chosen account
    rpc UpdateSource(AdminUpdateSourceRequest) returns (UpdateSourceResponse);
    // Deletes a source from a chosen account
    rpc DeleteSource(AdminDeleteSourceRequest) returns (DeleteSourceResponse);

    // Updates sources to keep them running in the background. This can be used
    // to add explicit action, when the built-in keepalives are not sufficient.
    rpc KeepaliveSources(AdminKeepaliveSourcesRequest) returns (KeepaliveSourcesResponse);

    // Create a new NATS token for a given public NKey. The user requesting must
    // control the associated private key also in order to connect to NATS as
    // the token is not enough on its own
    rpc CreateToken(AdminCreateTokenRequest) returns (CreateTokenResponse);

}

// TODO: Decide if I should have the admin requests return the exact same
// responses as the non-admin ones or should I change it?

message ListAccountsRequest {}
message ListAccountsResponse {
    repeated Account accounts = 1;
}

message CreateAccountRequest {
    AccountProperties properties = 1;
}
message CreateAccountResponse {
    Account account = 1;
}

message UpdateAccountRequest {
    AccountProperties properties = 1;
}
message UpdateAccountResponse {
    Account account = 1;
}
message AdminUpdateAccountRequest {
    // The name of the account to update
    string name = 1;
    UpdateAccountRequest request = 2;
}

message AdminGetAccountRequest {
    // The name of the account to get
    string name = 1;
}

message AdminDeleteAccountRequest {
    // The name of the account to delete
    string name = 1;
}
message AdminDeleteAccountResponse {}

message AdminListSourcesRequest {
    string account = 1;
    ListSourcesRequest request = 2;
}
message AdminCreateSourceRequest {
    string account = 1;
    CreateSourceRequest request = 2;
}
message AdminGetSourceRequest {
    string account = 1;
    GetSourceRequest request = 2;
}
message AdminUpdateSourceRequest {
    string account = 1;
    UpdateSourceRequest request = 2;
}
message AdminDeleteSourceRequest {
    string account = 1;
    DeleteSourceRequest request = 2;
}
message AdminKeepaliveSourcesRequest {
    string account = 1;
    KeepaliveSourcesRequest request = 2;
}
message AdminCreateTokenRequest {
    string account = 1;
    CreateTokenRequest request = 2;
}

// RPCs to manage the user's account, sources etc. All requests to this API are
// scoped to that user's account via the
// `https://api.overmind.tech/account-name` claim in the supplied token
service ManagementService {
    // Get the details of the account that this user belongs to
    rpc GetAccount(GetAccountRequest) returns (GetAccountResponse);
    // Completely deletes the user's account. This includes all of the data in
    // that account, bookmarks, changes etc. It also deletes the current user,
    // and all other users in that account from Auth0
    rpc DeleteAccount(DeleteAccountRequest) returns (DeleteAccountResponse);

    // Lists all sources within the user's account
    rpc ListSources(ListSourcesRequest) returns (ListSourcesResponse);
    // Creates a new source within the user's account
    rpc CreateSource(CreateSourceRequest) returns (CreateSourceResponse);
    // Get the details of a source
    rpc GetSource(GetSourceRequest) returns (GetSourceResponse);
    // Update the details of a source
    rpc UpdateSource(UpdateSourceRequest) returns (UpdateSourceResponse);
    // Deletes a source from a user's account
    rpc DeleteSource(DeleteSourceRequest) returns (DeleteSourceResponse);

    // Sources heartbeat and health
    // List of all recently active sources and their health, includes managed and local sources
    rpc ListAllSourcesStatus(ListAllSourcesStatusRequest) returns (ListAllSourcesStatusResponse);
    // Heartbeat from a source to keep it registered and healthy
    rpc SubmitSourceHeartbeat(SubmitSourceHeartbeatRequest) returns (SubmitSourceHeartbeatResponse);

    // Updates sources to keep them running in the background. This can be used
    // to add explicit action, when the built-in keepalives are not sufficient.
    rpc KeepaliveSources(KeepaliveSourcesRequest) returns (KeepaliveSourcesResponse);

    // Create a new NATS token for a given public NKey. The user requesting must
    // control the associated private key also in order to connect to NATS as
    // the token is not enough on its own
    rpc CreateToken(CreateTokenRequest) returns (CreateTokenResponse);

    // Ensure that all reverse links are populated. This does internal debouncing
    // so the actual logic does only run when required.
    rpc RevlinkWarmup(RevlinkWarmupRequest) returns (stream RevlinkWarmupResponse);

    rpc GetTrialEnd(GetTrialEndRequest) returns (GetTrialEndResponse);
}

enum SourceStatus {
    STATUS_UNSPECIFIED = 0;
    // The source is starting or updating
    STATUS_PROGRESSING = 1;
    // The source is healthy
    STATUS_HEALTHY = 2;
    // The source is unhealthy
    STATUS_UNHEALTHY = 3;
    // The source is sleeping due to inactivity. It will be woken up before it
    // is needed
    STATUS_SLEEPING = 4;
}

message Source {
    SourceMetadata metadata = 1;
    SourceProperties properties = 2;
}

message SourceMetadata {
    bytes UUID = 1; // TODO: Change to ID along with everything else

    // The name of the NATS JWT that has been generated for this source
    string TokenName = 2;

    // When the NATS JWT expires (unix time)
    google.protobuf.Timestamp TokenExpiry = 4;

    // The public NKey associated with the NATS JWT
    string PublicNkey = 5;

    // Status of the source
    SourceStatus Status = 9;

    // The error message if the source is unhealthy
    string Error = 10;

}

// A source that is capable of discovering items
message SourceProperties {
    // The descriptive name of the source
    string DescriptiveName = 1;

    // What source to configure. Currently either "stdlib" or "aws"
    string Type = 2;

    // Config for this source. See the source documentation for what
    // source-specific config is available/required. This will be supplied
    // directly to viper via a config file at `/etc/srcman/config/source.yaml`
    google.protobuf.Struct Config = 3;

    // Additional config options that should be passed to the source. The keys
    // of this object should be file names, and the values should be their
    // content. These files will be made available to the source at runtime.
    // Check the source's documentation for what to configure here if required
    google.protobuf.Struct AdditionalConfig = 4;
}

message Account {
    AccountMetadata metadata = 1;
    AccountProperties properties = 2;
}

message AccountMetadata {
    // The public Nkey which signs all NATS "user" tokens
    string PublicNkey = 2;
}

message AccountProperties {
    // The name of the account
    string Name = 1;
    // The Customer ID within Stripe
    string StripeCustomerID = 2;
}

message GetAccountRequest {}
message GetAccountResponse {
   Account account = 1;
}

message DeleteAccountRequest {
    // Set to true to confirm that the user is sure they want to delete their
    // account. This is to prevent accidental deletions
    bool iAmSure = 1;
}
message DeleteAccountResponse {}

message ListSourcesRequest {}
message ListSourcesResponse {
    repeated Source Sources = 1;
}

message CreateSourceRequest {
    SourceProperties properties = 1;
}

message CreateSourceResponse {
    Source source = 1;
}

message GetSourceRequest {
    bytes UUID = 1;
}

message GetSourceResponse {
    Source source = 1;
}

message UpdateSourceRequest {
    // ID of the source to update
    bytes UUID = 1;
    // Properties to update
    SourceProperties properties = 2;
}

message UpdateSourceResponse {
    Source source = 1;
}

message DeleteSourceRequest {
    // ID if the source to delete
    bytes UUID = 1;
}

message DeleteSourceResponse {}

message SourceKeepaliveResult {
    // The UUID of the source that was kept alive
    bytes UUID = 1;
    // The status of the source
    SourceStatus Status = 2;
    // The error message if the source is unhealthy
    string Error = 3;
}

message ListAllSourcesStatusRequest {}

enum ActiveSourceStatus {
    ACTIVE_SOURCE_STATUS_HEALTHY = 0;
    ACTIVE_SOURCE_STATUS_UNHEALTHY = 1;
    ACTIVE_SOURCE_STATUS_DISCONNECTED = 2;
}

// Whether the source is managed by srcman or was created by the user locally
enum SourceManaged {
    MANAGED = 0;
    LOCAL = 1;
}

message SourceHealth {
    // The UUID of the source
    bytes UUID = 1;
    // The version of the source
    string version  = 2;
    // The name of the source
    string name = 3;
    // The error message if the source is unhealthy
    optional string error = 4;
    // The status of the source, this is calculated based on the last heartbeat received and if there is an error
    ActiveSourceStatus status = 5;
    // Created at time
    google.protobuf.Timestamp createdAt = 6;
    // The last time we received a heartbeat from the source
    google.protobuf.Timestamp lastHeartbeat = 7;
    // The next time we expect to receive a heartbeat from the source
    google.protobuf.Timestamp nextHeartbeat = 8;
    // The type of the source, AWS or Stdlib or Kubernetes
    string type = 9;
    // Whether the source is managed, or local
    SourceManaged managed = 10;
    // The types of sources that this source can discover
    repeated string availableTypes = 11;
    // The scopes that this source can discover
    repeated string availableScopes = 12;
}

message ListAllSourcesStatusResponse {
    repeated SourceHealth sources = 1;
}

// The source sends a heartbeat to the API to let it know that it is still alive, note it does not give a status.
message SubmitSourceHeartbeatRequest {
    // The UUID of the source that is sending the heartbeat
    bytes UUID = 1;
    // The version of the source
    string version = 2;
    // The name of the source
    string name = 3;
    // The error message if the source is unhealthy
    optional string error = 4;
    // The interval until the source will send the next heartbeat, e.g. 10s
    google.protobuf.Duration nextHeartbeat = 5;
    // The type of the source, AWS or Stdlib or Kubernetes
    string type = 6;
    // Whether the source is managed, or local
    SourceManaged managed = 7;
    // The types of sources that this source can discover
    repeated string availableTypes = 8;
    // The scopes that this source can discover
    repeated string availableScopes = 9;
}

message SubmitSourceHeartbeatResponse {}

message KeepaliveSourcesRequest {
    // Set to true to have the API call wait until the source is up and healthy
    bool waitForHealthy = 1;
}
message KeepaliveSourcesResponse {
    // If the user requested to wait for the sources to be healthy, this will
    // contain information about the sources that came up. If the user did not
    // request to wait, this will be empty
    repeated SourceKeepaliveResult sources = 1;
}

message CreateTokenRequest {
    // The Public NKey of the user that is requesting a token
    string userPublicNkey = 1;

    // Friendly user name
    string userName = 2;
}

message CreateTokenResponse {
    // The JWT as a raw string
    string token = 1;
}

message RevlinkWarmupRequest {}

message RevlinkWarmupResponse {
    string status = 1;
    int32 items = 2;
    int32 edges = 3;
}

message GetTrialEndRequest {}

message GetTrialEndResponse {
    google.protobuf.Timestamp endsAt = 1;
}
